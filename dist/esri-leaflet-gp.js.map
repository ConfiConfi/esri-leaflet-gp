{"version":3,"file":"esri-leaflet-gp.js","sources":["esri-leaflet-gp-src.js"],"names":["EsriLeafletGP","Tasks","Services","Controls","window","L","esri","GP","Esri","Geoprocessing","Service","extend","options","asyncInterval","createTask","this","geoprocessing","Task","includes","Mixin","Events","params","resultParams","initialize","prototype","call","path","async","_service","metadata","error","results","console","log","executionType","fire","setParam","paramName","paramValue","_setGeometry","setOutputParam","outputParam","gpAsyncResultParam","geometry","processedInput","geometryType","features","LatLngBounds","push","Util","boundsToExtent","geojsonTypeToArcGIS","type","getLatLng","LatLng","coordinates","lng","lat","GeoJSON","getLayers","feature","geojsonToArcGIS","toGeoJSON","warn","run","callback","context","_done","request","response","processGPOutput","_currentJobId","jobId","checkJob","pollJob","jobStatus","clearInterval","counter","bind","setInterval","responseValue","processedResponse","value","featureCollection","responseToFeatureCollection","dataType","result"],"mappings":"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","sourcesContent":["/*! esri-leaflet-gp - v0.0.1-beta.1 - 2015-06-08\n*   Copyright (c) 2015 Environmental Systems Research Institute, Inc.\n*   Apache 2.0 License */\n\nvar EsriLeafletGP = {\n  Tasks: {},\n  Services: {},\n  Controls: {}\n};\n\n// attach to the L.esri global if we can\nif(typeof window !== 'undefined' && window.L && window.L.esri) {\n  window.L.esri.GP = EsriLeafletGP;\n}\n\n// We do not have an 'Esri' variable e.g loading this file directly from source define 'Esri'\nif(!Esri){\n  var Esri = window.L.esri;\n}\n\nEsriLeafletGP.Services.Geoprocessing = Esri.Services.Service.extend({\n  options: {\n    asyncInterval: 1\n  },\n\n  createTask: function(){\n    return new EsriLeafletGP.Tasks.Geoprocessing(this, this.options);\n  }\n});\n\nEsriLeafletGP.Services.geoprocessing = function(options) {\n  return new EsriLeafletGP.Services.Geoprocessing(options);\n};\n\n/*\nto do:\nsetParam([])\n*/\n\nEsriLeafletGP.Tasks.Geoprocessing = Esri.Tasks.Task.extend({\n\n  includes: L.Mixin.Events,\n\n  //setters: {}, we don't use these because we don't know the ParamName OR value of custom GP services\n  params: {},\n  resultParams: {},\n\n  initialize: function(options) {\n    //don't replace parent initialize\n    L.esri.Tasks.Task.prototype.initialize.call(this, options);\n\n    //if path isn't supplied in options, try and determine if its sync or async to set automatically\n    if (!this.options.path) {\n      //assume initially, that service is synchronous\n      this.options.async = false;\n      this.options.path = 'execute';\n\n      //the parameters below seem wonky to me, but work for both CORS and JSONP requests\n      this._service.metadata(function(error, results) {\n        if (!error) {\n          console.log(results);\n          if (results.executionType === 'esriExecutionTypeSynchronous') {\n            this.options.async = false;\n            this.options.path = 'execute';\n          } else {\n            this.options.async = true;\n            this.options.path = 'submitJob';\n          }\n          this.fire('initialized');\n        } else {\n          //if check fails, hopefully its synchronous\n          this.options.async = false;\n          this.options.path = 'execute';\n          return;\n        }\n      }, this);\n    }\n    else {\n      //if path is custom, hopefully its synchronous\n      if (this.options.async !== true && this.options.path !=='submitJob') {\n        this.options.async = false;\n      }\n    }\n  },\n\n  //doc for various GPInput types can be found here\n  //http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/GP_Result/02r3000000q7000000/\n\n  //set booleans, numbers, strings\n  setParam: function(paramName, paramValue) {\n    if (typeof paramValue === 'boolean') {\n      this.params[paramName] = paramValue;\n      return;\n    }\n    //strings, numbers\n    else if (typeof paramValue !== 'object') {\n      this.params[paramName] = paramValue;\n      return;\n    }\n    else {\n      //otherwise assume its latlng, marker, bounds or geojson\n      this._setGeometry(paramName, paramValue);\n    }\n  },\n\n  // not sure how best to handle passing more than one parameter at once\n  // setParams: function(inputArray) {\n  //   if (L.Util.isArray(inputArray)) {\n  //     for (var i = 0; i < inputArray.length; i++) {\n  //       this.setParam(inputArray[i]);\n  //     }\n  //   }\n  // },\n\n  // give developer opportunity to point out where the output is going to be available\n  setOutputParam: function(paramName) {\n    this.params.outputParam = paramName;\n  },\n\n  /* necessary because of the design requirement that resultParams be specified\n  for async elevation services in order to get Zs (unnecessarily confusing)*/\n  gpAsyncResultParam: function(paramName, paramValue) {\n    this.resultParams[paramName] = paramValue;\n  },\n\n  // we currently expect a single geometry or feature (ported from: Tasks.Query._setGeometry)\n  _setGeometry: function(paramName, geometry) {\n    var processedInput = {\n      'geometryType': '',\n      'features': []\n    };\n\n    // convert bounds to extent and finish\n    if ( geometry instanceof L.LatLngBounds ) {\n      // set geometry + type\n      processedInput.features.push({'geometry': L.esri.Util.boundsToExtent(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // convert L.Marker > L.LatLng\n    if(geometry.getLatLng){\n      geometry = geometry.getLatLng();\n    }\n\n    // convert L.LatLng to a geojson point and continue;\n    if (geometry instanceof L.LatLng) {\n      geometry = {\n        type: 'Point',\n        coordinates: [geometry.lng, geometry.lat]\n      };\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if ( geometry instanceof L.GeoJSON ) {\n      //reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\n      geometry = geometry.getLayers()[0].feature.geometry;\n      processedInput.features.push({'geometry': L.esri.Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if ( geometry.type === 'Feature' ) {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if ( geometry.type === 'Point' ||  geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      processedInput.features.push({'geometry': L.esri.Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    else {\n      if(console && console.warn) {\n        console.warn('invalid geometry passed as GP input. Should be an L.LatLng, L.LatLngBounds, L.Marker or GeoJSON Point Line or Polygon object');\n      }\n    }\n\n    this.params[paramName] = processedInput;\n    return;\n  },\n\n  run: function(callback, context) {\n    this._done = false;\n\n    if (this.options.async === true) {\n      this._service.request(this.options.path, this.params, function(error, response) {\n        this._currentJobId = response.jobId;\n        this.checkJob(this._currentJobId, callback, context);\n      }, this);\n    } else {\n      return this._service.request(this.options.path, this.params, function(error, response) {\n        callback.call(context, error, (response && this.processGPOutput(response)), response);\n      }, this);\n    }\n  },\n\n  checkJob: function(jobId, callback, context) {\n    var pollJob = function() {\n      this._service.request('jobs/' + jobId, {}, function polledJob(error, response) {\n        if (response.jobStatus === 'esriJobSucceeded') {\n          if (!this._done){\n            this._done = true;\n            this._service.request('jobs/' + jobId + '/results/' + this.params.outputParam, this.resultParams, function processJobResult(error, response) {\n              callback.call(context, error, (response && this.processGPOutput(response)), response);\n            }, this);\n          }\n          window.clearInterval(counter);\n        } else if (response.jobStatus === 'esriJobFailed') {\n          callback.call(context, 'Job Failed', null);\n          window.clearInterval(counter);\n        }\n      }, this);\n    }.bind(this);\n\n    var counter = window.setInterval(pollJob, this._service.options.asyncInterval*1000);\n\n  },\n\n  processGPOutput: function(response) {\n    var processedResponse = {};\n    var responseValue;\n\n    if (this.options.async === false) {\n      responseValue = response.results[0].value;\n    } else {\n      responseValue = response.value;\n      processedResponse.jobId = this._currentJobId;\n    }\n\n    if (responseValue.features) {\n      var featureCollection = L.esri.Util.responseToFeatureCollection(responseValue);\n      processedResponse.features = featureCollection.features;\n    } else if (response.results[0].dataType === 'GPDataFile') {\n      processedResponse.result = response.results[0];\n    }\n    //do we need to be able to pass back output booleans? strings? numbers?\n    return processedResponse;\n  }\n\n});\n\nEsriLeafletGP.Tasks.geoprocessing = function(params) {\n  return new EsriLeafletGP.Tasks.Geoprocessing(params);\n};\n"]}