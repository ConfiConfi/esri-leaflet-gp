{"version":3,"file":"esri-leaflet-gp.js","sources":["esri-leaflet-gp-src.js"],"names":["EsriLeafletGP","Tasks","Services","Controls","window","L","esri","GP","Esri","Geoprocessing","Service","extend","options","createTask","this","geoprocessing","Task","includes","Mixin","Events","params","resultParams","initialize","prototype","call","path","async","_service","metadata","error","results","executionType","fire","setParam","paramName","paramValue","_setGeometry","gpAsyncResultParam","geometry","processedInput","geometryType","features","LatLngBounds","push","Util","boundsToExtent","geojsonTypeToArcGIS","type","getLatLng","LatLng","coordinates","lng","lat","GeoJSON","getLayers","feature","geojsonToArcGIS","toGeoJSON","console","warn","run","callback","context","jobId","request","response","processGPOutput","checkJob","pollJob","jobStatus","clearInterval","counter","bind","setInterval","responseValue","processedResponse","value","featureCollection","responseToFeatureCollection","dataType","result"],"mappings":"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","sourcesContent":["/*! esri-leaflet-gp - v1.0.0-alpha.3 - 2015-03-05\n*   Copyright (c) 2015 Environmental Systems Research Institute, Inc.\n*   Apache 2.0 License */\n\nvar EsriLeafletGP = {\n  Tasks: {},\n  Services: {},\n  Controls: {}\n};\n\n// attach to the L.esri global if we can\nif(typeof window !== 'undefined' && window.L && window.L.esri) {\n  window.L.esri.GP = EsriLeafletGP;\n}\n\n// We do not have an 'Esri' variable e.g loading this file directly from source define 'Esri'\nif(!Esri){\n  var Esri = window.L.esri;\n}\n\nEsriLeafletGP.Services.Geoprocessing = Esri.Services.Service.extend({\n  options: {},\n\n  createTask: function(){\n    return new EsriLeafletGP.Tasks.Geoprocessing(this, this.options);\n  }\n});\n\nEsriLeafletGP.Services.geoprocessing = function(options) {\n  return new EsriLeafletGP.Services.Geoprocessing(options);\n};\n\n/*\nto do:\nsetParam([])\n*/\n\nEsriLeafletGP.Tasks.Geoprocessing = Esri.Tasks.Task.extend({\n\n  includes: L.Mixin.Events,\n\n  //setters: {}, we don't use these because we don't know the ParamName OR value of custom GP services\n  params: {},\n  resultParams: {},\n\n  initialize: function(options) {\n    //don't replace parent initialize\n    L.esri.Tasks.Task.prototype.initialize.call(this, options);\n\n    //if path isn't supplied in options, try and determine if its sync or async to set automatically\n    if (!this.options.path) {\n      //the parameters below seem wonky to me, but work for both CORS and JSONP requests\n      this._service.metadata(function(error, results) {\n        if (!error) {\n          if (results.executionType === 'esriExecutionTypeSynchronous') {\n            this.options.async = false;\n            this.options.path = 'execute';\n          } else {\n            this.options.async = true;\n            this.options.path = 'submitJob';\n          }\n          this.fire('initialized');\n        } else {\n          //if check fails, hopefully its synchronous\n          this.options.async = false;\n          this.options.path = 'execute';\n          return;\n        }\n      }, this);\n    }\n    else {\n      //if path is custom, hopefully its synchronous\n      if (this.options.async !== true && this.options.path !=='submitJob') {\n        this.options.async = false;\n      }\n    }\n  },\n\n  //doc for various GPInput types can be found here\n  //http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/GP_Result/02r3000000q7000000/\n\n  //set booleans, numbers, strings\n  setParam: function(paramName, paramValue) {\n    if (typeof paramValue === 'boolean') {\n      this.params[paramName] = paramValue;\n      return;\n    }\n    //strings, numbers\n    else if (typeof paramValue !== 'object') {\n      this.params[paramName] = paramValue;\n      return;\n    }\n    else {\n      //otherwise assume its latlng, marker, bounds or geojson\n      this._setGeometry(paramName, paramValue);\n    }\n  },\n\n  // not sure how best to handle passing more than one parameter at once\n  // setParams: function(inputArray) {\n  //   if (L.Util.isArray(inputArray)) {\n  //     for (var i = 0; i < inputArray.length; i++) {\n  //       this.setParam(inputArray[i]);\n  //     }\n  //   }\n  // },\n\n  //necessary because of the design requirement that resultParams be specified for async elevation services in order to get Zs (unnecessarily confusing)\n  gpAsyncResultParam: function(paramName, paramValue) {\n    this.resultParams[paramName] = paramValue;\n  },\n\n  // we currently expect a single geometry or feature (ported from: Tasks.Query._setGeometry)\n  _setGeometry: function(paramName, geometry) {\n    var processedInput = {\n      'geometryType': '',\n      'features': []\n    };\n\n    // convert bounds to extent and finish\n    if ( geometry instanceof L.LatLngBounds ) {\n      // set geometry + type\n      processedInput.features.push({'geometry': L.esri.Util.boundsToExtent(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // convert L.Marker > L.LatLng\n    if(geometry.getLatLng){\n      geometry = geometry.getLatLng();\n    }\n\n    // convert L.LatLng to a geojson point and continue;\n    if (geometry instanceof L.LatLng) {\n      geometry = {\n        type: 'Point',\n        coordinates: [geometry.lng, geometry.lat]\n      };\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if ( geometry instanceof L.GeoJSON ) {\n      //reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\n      geometry = geometry.getLayers()[0].feature.geometry;\n      processedInput.features.push({'geometry': L.esri.Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if ( geometry.type === 'Feature' ) {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if ( geometry.type === 'Point' ||  geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      processedInput.features.push({'geometry': L.esri.Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    else {\n      if(console && console.warn) {\n        console.warn('invalid geometry passed as GP input. Should be an L.LatLng, L.LatLngBounds, L.Marker or GeoJSON Point Line or Polygon object');\n      }\n    }\n\n    this.params[paramName] = processedInput;\n    return;\n  },\n\n  run: function(callback, context) {\n    var jobId;\n    if (this.options.async === true) {\n      this._service.request(this.options.path, this.params, function(error, response) {\n        jobId = response.jobId;\n        this.checkJob(jobId, callback, context);\n      }, this);\n    } else {\n      return this._service.request(this.options.path, this.params, function(error, response) {\n        callback.call(context, error, (response && this.processGPOutput(response)), response);\n      }, this);\n    }\n  },\n\n  checkJob: function(jobId, callback, context) {\n    var pollJob = function() {\n      this.request('/jobs/' + jobId, {}, function polledJob(error, response) {\n        if (response.jobStatus === 'esriJobSucceeded') {\n          this.request('/jobs/' + jobId + '/results/OutputProfile', this.resultParams, function processJobResult(error, response) {\n            callback.call(context, error, (response && this.processGPOutput(response)), response);\n\n          }, this);\n          window.clearInterval(counter);\n        } else if (response.jobStatus === 'esriJobFailed') {\n          callback.call(context, 'Job Failed', null);\n          window.clearInterval(counter);\n        }\n      }, this);\n    }.bind(this);\n\n    var counter = window.setInterval(pollJob, 1000);\n\n  },\n\n  processGPOutput: function(response) {\n    var processedResponse = {};\n    var responseValue;\n\n    if (this.options.async === false) {\n      responseValue = response.results[0].value;\n    } else {\n      responseValue = response.value;\n    }\n\n    if (responseValue.features) {\n      var featureCollection = L.esri.Util.responseToFeatureCollection(responseValue);\n      processedResponse.features = featureCollection.features;\n    } else if (response.results[0].dataType === 'GPDataFile') {\n      processedResponse.result = response.results[0];\n    }\n    //do we need to be able to pass back output booleans? strings? numbers?\n    return processedResponse;\n  }\n\n});\n\nEsriLeafletGP.Tasks.geoprocessing = function(params) {\n  return new EsriLeafletGP.Tasks.Geoprocessing(params);\n};"]}